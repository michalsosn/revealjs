<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Droga do Warszawy</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/white.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/tomorrow.css">
		<link rel="stylesheet" href="lib/css/vis.min.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section data-markdown>
                    <script type="text/template">
                        ## Graf miast

                        Warunki:

                        - Tylko autostrady
                        - Przynajmniej dwa miasta o populacji ponad 400 000
                        - Miasto w innej części Polski (północ/południe, wschód/zachód)

                        Rozwiązanie: 
                        
                        [_Google Maps API_](https://developers.google.com/maps/) (Distance Matrix i Geocoding)
                    </script>
                </section>
				<section data-markdown>
                    <script type="text/template">
                        ## Tylko autostrady

                        - Pobranie z _Distance Matrix API_ odległości $49 \times 49$
                        - Pobranie drugiej macierzy z opcją _avoid=highways_
                        - Tylko autostrady - zachowujemy połączenia, gdzie odległości z pominięciem autostrad są inne.
                        - Tylko bezpośrednie - usuwamy $A \to B$ jeżeli istnieje $C$, że $d(A, C) + d(C, B) < 1.2 d(A, B)$

                        Zostało 256 połączeń! (rysunek później)
                    </script>
                </section>
				<section data-markdown>
                    <script type="text/template">
                        ## Populacja ponad 400 000

                        Uznajemy, że przejście przez Warszawę nie wypełnia tego warunku.
                        <small>
                        <table>
                            <tr><th>Miasto</th><th>[Populacja](https://pl.wikipedia.org/wiki/Miasta_w_Polsce)</th></tr>
                            <tr><td>Warszawa</td><td>1 748 916</td></tr>
                            <tr><td>Kraków</td><td>762 448</td></tr>
                            <tr><td>Łódź</td><td>698 688</td></tr>
                            <tr><td>Wrocław</td><td>637 075</td></tr>
                            <tr><td>Poznań</td><td>541 561</td></tr>
                            <tr><td>Gdańsk</td><td>462 996</td></tr>
                            <tr><td>Szczecin</td><td>405 413</td></tr>
                        </table>
                        </small>
                    </script>
                </section>
				<section data-markdown>
                    <script type="text/template">
                        ## Inna część Polski

                        - Centrum Polski - N$51.9194^\circ$ E$19.1451^\circ$
                        - Korzystając z _Geocoding API_, dla każdego miasta uzyskałem współrzędne geograficzne.
                        - Jeżeli $\Delta \lambda > \Delta \phi$, to miasto leży w północnej lub południowej częśći Polski. 
                        - Jak na odwrót, to we wschodniej lub zachodniej.
                    </script>
                </section>
				<section data-markdown>
                    <script type="text/template">
                        ## Graf miast - mapa

                        ![Mapa połączeń miast Polski](warsaw/connections.png)
                    </script>
                </section>
				<section data-markdown>
                    <script type="text/template">
                        ## Odległości do Warszawy

                        Rozwiązanie:

                        - Korzystając z _Geocoding API_, dla każdego miasta uzyskałem współrzędne geograficzne.
                        - Mając ich współrzędne, obliczyłem odległość w linii prostej do Warszawy. (_haversine formula_)
                    </script>
                </section>
				<section data-markdown>
                    <script type="text/template">
                        ## Funkcja heurystyczna

                        Maksimum z:
                        - Odległości do Warszawy.
                        - Najmniejszej odległości do Warszawy przechodzącej przez miasto o populacji 400 000 
                        - Najmniejszej odległości do Warszawy przechodzącej przez miasto w innej części Polski

                        Ostatnie punkty tylko, gdy warunki są niespełnione.

                        Wszystkie wyliczone wcześniej i zapisane.
                    </script>
                </section>
				<section data-markdown>
                    <script type="text/template">
                        ## Algorytm

                            def astar_search(start, end, distances, heuristic, h_weight=0.5, init_state=Condition.NONE):
                                d_weight = 1.0 - h_weight
                                size, _ = distances.shape
                                
                                visited = np.zeros(size, dtype=np.int32)
                                queue = [(0, start, 0, init_state, [start])]
                                
                                while queue:
                                    _, current, current_distance, state, path = hq.heappop(queue)
                                    
                                    visited[current] += 1
                                    
                                    if current == end:
                                        return (path, visited)
                                    
                                    for neighbor in range(size):
                                        edge_distance = distances[current, neighbor]
                                        if edge_distance == 0:
                                            continue
                                        if neighbor in path:
                                            continue
                                        if neighbor == end and state != Condition.ALL:
                                            continue
                                            
                                        new_state = state | get_condition_flag(state, current, neighbor, path)
                                        
                                        path_distance = current_distance + edge_distance
                                        h_score = heuristic(neighbor, new_state)
                                        f_score = d_weight * path_distance + h_weight * h_score
                                        
                                        new_path = path[:]
                                        new_path.append(neighbor)
                                        
                                        hq.heappush(queue, (f_score, neighbor, path_distance, new_state, new_path))
                                            
                                return (None, visited)
                    </script>
                </section>
				<section data-markdown>
                    <script type="text/template">
                        ## Wyniki - A star

                        ![Ścieżka z Przemyśla - Algorytm A-star](warsaw/astar.png)
                    </script>
                </section>
				<section data-markdown>
                    <script type="text/template">
                        ## Wyniki - Djikstra

                        ![Ścieżka z Przemyśla - Algorytm Djikstra](warsaw/djikstra.png)
                    </script>
                </section>
				<section data-markdown>
                    <script type="text/template">
                        ## Wyniki - Best-first

                        ![Ścieżka z Przemyśla - Algorytm best-first](warsaw/best-first.png)
                    </script>
                </section>
				<section data-markdown>
                    <script type="text/template">
                        ## Wyniki - podsumowanie

                        <small>
                        <table>
                            <tr><th>Wariant</th><th>Średnia długość ścieżki</th><th>Średnia liczba odwiedzin</th></tr>
                            <tr><td>Best-first</td><td>7.21</td><td>50.25</td></tr>
                            <tr><td>A star</td><td>6.69</td><td>5474.79</td></tr>
                            <tr><td>Djikstra</td><td>6.69</td><td>5491.00</td></tr>
                        </table>
                        </small>
                    </script>
                </section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			Reveal.initialize({
				history: true,
                anything: [ 
                    {
                        className: "visjs",  
                        defaults: { options: {} },
                        initialize: (function(container, options) { 
                            container.network = new vis.Network(
                                container, { nodes: new vis.DataSet(options.nodes), edges: new vis.DataSet(options.edges) }, options.options || {}
                            ); 
                        })
                    },
                ],
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'plugin/math/math.js', async: true },
                    { src: 'plugin/anything/anything.js' },
                    { src: 'lib/js/vis.min.js' },
				]
			});
		</script>
	</body>
</html>
